import { request } from './utils/main-process-bridge';
import type { ReadConfKeyMap } from '../types';

export class API {

  getConfigurations(options?: {invalidateCache: boolean}) {
    return request('getConfigurations', options);
  }

  listWorkspaces(siteKey: string){
    return request('listWorkspaces', {siteKey});
  }

  getWorkspaceModelParseInfo(siteKey: string, workspaceKey: string) {
    return request('getWorkspaceModelParseInfo', {siteKey, workspaceKey});
  }

  getWorkspaceDetails(siteKey: string, workspaceKey: string) {
    return request('getWorkspaceDetails', {siteKey, workspaceKey});
  }

  getPromptTemplateConfig(siteKey: string, workspaceKey: string, templateKey: string) {
    return request('getPromptTemplateConfig', {siteKey, workspaceKey, templateKey});
  }

  processAiPrompt(
    siteKey: string,
    workspaceKey: string,
    templateKey: string,
    formValues: Record<string, unknown>,
    context: {
      collectionKey?: string;
      collectionItemKey?: string;
      singleKey?: string;
    }
  ) {
    return request('processAiPrompt', {
      siteKey,
      workspaceKey,
      templateKey,
      formValues,
      context
    });
  }

  updatePageFromAiResponse(
    siteKey: string,
    workspaceKey: string,
    aiResponse: string,
    context: {
      collectionKey?: string;
      collectionItemKey?: string;
      singleKey?: string;
    }
  ) {
    return request('updatePageFromAiResponse', {
      siteKey,
      workspaceKey,
      aiResponse,
      context
    });
  }

  getPreviewCheckConfiguration() {
    return request('getPreviewCheckConfiguration', {});
  }

  serveWorkspace(siteKey: string, workspaceKey: string, serveKey: string){
    return request('serveWorkspace', {siteKey, workspaceKey, serveKey});
  }

  stopHugoServer(){
    return request('stopHugoServer', {}, {timeout:100000});
  }

  showLogWindow(){
    return request('showLogWindow', {});
  }

  logToConsole( message, label = ""){
    return request('logToConsole', {message, label}, {timeout: 1000});
  }

  getDynFormFields(searchRootNode: string, searchLevelKeyVal: any){
    return request('getDynFormFields', {searchRootNode, searchLevelKeyVal});
  }

  importSite(){
    return request('importSiteAction', {});
  }

  /**
   * @deprecated Use getFilteredSSGVersions instead
   */
  getFilteredHugoVersions(){
    return request('getFilteredHugoVersions', {});
  }

  /**
   * Get filtered versions for a specific SSG type
   */
  getFilteredSSGVersions(ssgType: string) {
    return request('getFilteredSSGVersions', { ssgType });
  }

  /**
   * @deprecated Use checkSSGVersion instead
   */
  checkHugoVersion(version: string) {
    return request('checkHugoVersion', { version });
  }

  /**
   * Check if an SSG version is installed
   */
  checkSSGVersion(ssgType: string, version: string) {
    return request('checkSSGVersion', { ssgType, version });
  }

  importSiteFromPrivateGitRepo(
    gitBaseUrl: string,
    gitOrg: string,
    gitRepo: string,
    privKey: string,
    gitEmail: string,
    saveSyncTarget: boolean,
    siteName: string,
    protocol: 'ssh' | 'https' = 'ssh',
    sshPort: number = 22,
    gitProvider: 'github' | 'gitlab' | 'forgejo' | 'generic' = 'generic'
  ){
    return request('importSiteFromPrivateGitRepo', {gitBaseUrl, gitOrg, gitRepo, privKey, gitEmail, saveSyncTarget, siteName, protocol, sshPort, gitProvider}, {timeout: 1000000});
  }

  importSiteFromPublicGitUrl(siteName: string, url: string){
    return request('importSiteFromPublicGitUrl', {siteName, url}, {timeout: 1000000});
  }

  newSiteFromPublicHugoThemeUrl(siteName: string, url: string, themeInfo: any, hugoVersion){
    return request('newSiteFromPublicHugoThemeUrl', {siteName, url, themeInfo, hugoVersion});
  }

  newSiteFromLocalDirectory(siteName: string, directory: string, generateQuiqrModel: boolean, hugoVersion: string){
    return request('newSiteFromLocalDirectory', {siteName, directory, generateQuiqrModel, hugoVersion});
  }

  deleteSite(siteKey: string){
    return request('deleteSite', {siteKey});
  }
  newSiteFromScratch(siteName: string, hugoVersion, configFormat){
    return request('newSiteFromScratch', {siteName, hugoVersion, configFormat});
  }

  getCurrentBaseUrl(){
    return request('getCurrentBaseUrl', {});
  }

  getCurrentSiteKey(){
    return request('getCurrentSiteKey', {});
  }

  globSync(pattern, options){
    return request('globSync', {pattern, options});
  }

  parseFileToObject(file){
    return request('parseFileToObject', {file});
  }

  buildWorkspace(siteKey: string, workspaceKey: string, buildKey: string, extraConfig: any){
    return request('buildWorkspace', {siteKey, workspaceKey, buildKey, extraConfig});
  }

  saveSingle(siteKey: string, workspaceKey: string, singleKey: string, document: string){
    return request('saveSingle', {siteKey, workspaceKey, singleKey, document});
  }

  getSingle(siteKey: string, workspaceKey: string, singleKey: string, fileOverride: string){
    return request('getSingle', {siteKey, workspaceKey, singleKey, fileOverride});
  }

  openSingleInEditor(siteKey: string, workspaceKey: string, singleKey: string){
    return request('openSingleInEditor', {siteKey, workspaceKey, singleKey});
  }
  updateSingle(siteKey: string, workspaceKey: string, singleKey: string, document: any){
    return request('updateSingle', {siteKey, workspaceKey, singleKey, document});
  }

  listCollectionItems(siteKey: string, workspaceKey: string, collectionKey: string){
    return request('listCollectionItems', {siteKey, workspaceKey, collectionKey});
  }

  getCollectionItem(siteKey: string, workspaceKey: string, collectionKey: string, collectionItemKey: string){
    return request('getCollectionItem', {siteKey, workspaceKey, collectionKey, collectionItemKey});
  }

  openCollectionItemInEditor(siteKey: string, workspaceKey: string, collectionKey: string, collectionItemKey: string){
    return request('openFileDialogForCollectionItem', {siteKey, workspaceKey, collectionKey, collectionItemKey});
  }

  buildCollectionItem(siteKey: string, workspaceKey: string, collectionKey: string, collectionItemKey: string, buildAction: string){
    return request('buildCollectionItem', {siteKey, workspaceKey, collectionKey, collectionItemKey, buildAction});
  }
  buildSingle(siteKey: string, workspaceKey: string, singleKey: string, buildAction: string){
    return request('buildSingle', {siteKey, workspaceKey, singleKey, buildAction});
  }

  updateCollectionItem(siteKey: string, workspaceKey: string, collectionKey: string, collectionItemKey: string, document: any){
    return request('updateCollectionItem', {siteKey, workspaceKey, collectionKey, collectionItemKey, document});
  }

  createCollectionItemKey(siteKey: string, workspaceKey: string, collectionKey: string, collectionItemKey: string, itemTitle: string){
    return request('createCollectionItemKey', {siteKey, workspaceKey, collectionKey, collectionItemKey, itemTitle});
  }

  deleteCollectionItem(siteKey: string, workspaceKey: string, collectionKey: string, collectionItemKey: string){
    return request('deleteCollectionItem', {siteKey, workspaceKey, collectionKey, collectionItemKey});
  }

  makePageBundleCollectionItem(siteKey: string, workspaceKey: string, collectionKey: string, collectionItemKey: string){
    return request('makePageBundleCollectionItem', {siteKey, workspaceKey, collectionKey, collectionItemKey});
  }

  matchRole(role: string){
    return request('matchRole', {role});
  }

  readConfKey<K extends keyof ReadConfKeyMap>(confkey: K): Promise<ReadConfKeyMap[K]> {
    return request('readConfKey', {confkey}) as Promise<ReadConfKeyMap[K]>;
  }

  readConfPrefKey(confkey: string){
    return request('readConfPrefKey', {confkey});
  }

  checkFreeSiteName(proposedSiteName: string){
    return request('checkFreeSiteName', {proposedSiteName});
  }

  saveConfPrefKey(prefKey: string, prefValue: unknown){
    return request('saveConfPrefKey', {prefKey, prefValue});
  }

  renameCollectionItem(siteKey: string, workspaceKey: string, collectionKey: string, collectionItemKey: string, collectionItemNewKey: string){
    return request('renameCollectionItem', {siteKey, workspaceKey, collectionKey, collectionItemKey, collectionItemNewKey});
  }
  copyCollectionItem(siteKey: string, workspaceKey: string, collectionKey: string, collectionItemKey: string, collectionItemNewKey: string){
    return request('copyCollectionItem', {siteKey, workspaceKey, collectionKey, collectionItemKey, collectionItemNewKey});
  }

  copyCollectionItemToLang(siteKey: string, workspaceKey: string, collectionKey: string, collectionItemKey: string, collectionItemNewKey: string, destLang: string){
    return request('copyCollectionItemToLang', {siteKey, workspaceKey, collectionKey, collectionItemKey, collectionItemNewKey, destLang});
  }

  openFileInEditor(filepath: string, create: boolean = false, relativeToRoot: boolean = false){
    return request('openFileInEditor', {filepath, create, relativeToRoot});
  }

  openFileExplorer(filepath: string, relativeToRoot: boolean = false){
    return request('openFileExplorer', {filepath, relativeToRoot});
  }

  /**
   * Opens a file dialog and uploads selected files into a collection item.
   *
   * Uses HTML5 file inputs for cross-platform compatibility (works in both Electron and browser mode).
   * Files are read as base64 and uploaded via the uploadFileToBundlePath API.
   */
  openFileDialogForSingleAndCollectionItem(
    siteKey: string,
    workspaceKey: string,
    collectionKey: string,
    collectionItemKey: string,
    targetPath: string,
    { title: _title, extensions }:{title: string, extensions: Array<string>},
    forceFileName?: string
  ){
    return new Promise<void>((resolve, reject) => {
      // Create hidden file input
      const input = document.createElement('input');
      input.type = 'file';
      input.multiple = !forceFileName; // Single file if forceFileName is set
      input.accept = extensions.map(ext => `.${ext}`).join(',');

      input.onchange = async (e) => {
        const files = (e.target as HTMLInputElement).files;
        if (!files || files.length === 0) {
          resolve();
          return;
        }

        try {
          let newCollectionItemKey: string | undefined;

          // Upload each selected file
          for (const file of Array.from(files)) {
            // Read file as base64
            const base64Content = await new Promise<string>((res, rej) => {
              const reader = new FileReader();
              reader.onload = () => {
                const result = reader.result as string;
                // Remove data URL prefix (e.g., "data:image/png;base64,")
                res(result.split(',')[1]);
              };
              reader.onerror = rej;
              reader.readAsDataURL(file);
            });

            // Determine filename
            const filename = forceFileName
              ? `${forceFileName}.${file.name.split('.').pop()}`
              : file.name;

            // Upload to backend via base64
            const result = await this.uploadFileToBundlePath(
              siteKey,
              workspaceKey,
              collectionKey,
              collectionItemKey,
              targetPath,
              filename,
              base64Content
            );

            // Track if item was converted to bundle
            if (result.newCollectionItemKey) {
              newCollectionItemKey = result.newCollectionItemKey;
            }
          }

          // If item was converted to bundle, redirect to the new URL
          if (newCollectionItemKey) {
            const newUrl = `/workspace/${siteKey}/${workspaceKey}/collection/${collectionKey}/item/${encodeURIComponent(newCollectionItemKey)}`;
            window.location.href = newUrl;
          }

          resolve();
        } catch (error) {
          console.error('Error uploading files:', error);
          this.logToConsole(error, 'File upload error');
          reject(error);
        } finally {
          // Cleanup
          document.body.removeChild(input);
        }
      };

      input.oncancel = () => {
        document.body.removeChild(input);
        resolve();
      };

      // Add to DOM (required for some browsers) and trigger
      input.style.display = 'none';
      document.body.appendChild(input);
      input.click();
    });
  }
  quiqr_git_repo_show(url: string){
    return request('quiqr_git_repo_show', {url}, {timeout: 300000});
  }

  hugotheme_git_repo_show(url: string){
    return request('hugotheme_git_repo_show', {url}, {timeout: 30000});
  }

  hugosite_dir_show(folder: string){
    return request('hugosite_dir_show', {folder}, {timeout: 30000});
  }
  openCustomCommand(command: string){
    return request('openCustomCommand', {command});
  }

  openExternal(url: string) {
    return request('openExternal', { url });
  }

  getThumbnailForPath(siteKey: string, workspaceKey: string, targetPath: string){
    return request('getThumbnailForPath', {siteKey, workspaceKey, targetPath}, {timeout: 400000});
  }

  getThumbnailForCollectionOrSingleItemImage(siteKey: string, workspaceKey: string, collectionKey: string, collectionItemKey: string, targetPath: string){
    return request('getThumbnailForCollectionOrSingleItemImage', {siteKey, workspaceKey, collectionKey, collectionItemKey, targetPath}, {timeout: 30000});
  }

  getFilesInBundle(siteKey: string, workspaceKey: string, collectionKey: string, collectionItemKey: string, targetPath: string, extensions: any, forceFileName: string){
    return request('getFilesInBundle', {siteKey, workspaceKey, collectionKey, collectionItemKey, targetPath, extensions, forceFileName});
  }

  uploadFileToBundlePath(
    siteKey: string,
    workspaceKey: string,
    collectionKey: string,
    collectionItemKey: string,
    targetPath: string,
    filename: string,
    base64Content: string
  ) {
    return request('uploadFileToBundlePath', {
      siteKey,
      workspaceKey,
      collectionKey,
      collectionItemKey,
      targetPath,
      filename,
      base64Content
    }) as Promise<{ uploadedPath: string; newCollectionItemKey?: string }>;
  }

  deleteFileFromBundle(
    siteKey: string,
    workspaceKey: string,
    collectionKey: string,
    collectionItemKey: string,
    targetPath: string,
    filename: string
  ) {
    return request('deleteFileFromBundle', {
      siteKey,
      workspaceKey,
      collectionKey,
      collectionItemKey,
      targetPath,
      filename
    });
  }

  getFilesFromAbsolutePath(path: string){
    return request('getFilesFromAbsolutePath', {path}, {timeout: 30000});
  }

  saveSiteConf(siteKey: string, newConf: any){
    return request('saveSiteConf', {siteKey, newConf});
  }

  copySite(siteKey: string, newConf: any){
    return request('copySite', {siteKey, newConf});
  }

  /*
  mergeSiteWithRemote(siteKey: string, publishConf: any){
    return request('mergeSiteWithRemote', {siteKey, publishConf}, {timeout: 130000});
  }

  publishSite(siteKey: string, publishConf: any){
    return request('publishSite', {siteKey, publishConf}, {timeout: 130000});
  }
  */

  getSiteConfig(siteKey: string){
    return request('getSiteConfig', {siteKey});
  }

  getLanguages(siteKey: string, workspaceKey: string){
    return request('getLanguages', {siteKey, workspaceKey});
  }

  publisherDispatchAction(siteKey: string, publishConf: any, action: string, actionParameters: any, timeout: any){
    if(!Number.isInteger(timeout)){
      timeout=130000;
    }
    return request('publisherDispatchAction', {siteKey, publishConf, action, actionParameters}, {timeout: timeout});
  }

  getCreatorMessage(siteKey: string, workspaceKey: string){
    return request('getCreatorMessage', {siteKey, workspaceKey});
  }

  getHugoTemplates(){
    return request('getHugoTemplates', null, {timeout: 30000});
  }

  openSiteLibrary(){
    return request('openSiteLibrary', {}, {timeout: 100000 });
  }
  showMenuBar(){
    return request('showMenuBar', {});
  }
  hideMenuBar(){
    return request('hideMenuBar', {});
  }

  mountWorkspace(siteKey: string, workspaceKey: string){
    return request('mountWorkspace', {siteKey, workspaceKey});
  }

  shouldReloadForm(reloadFormPath: string){
    return request('shouldReloadForm', {reloadFormPath});
  }

  setCurrentFormAccordionIndex(index: string){
    return request('setCurrentFormAccordionIndex', {index});
  }

  getCurrentFormAccordionIndex(){
    return request('getCurrentFormAccordionIndex', {});
  }

  setCurrentFormNodePath(path: string){
    return request('setCurrentFormNodePath', {path});
  }

  getCurrentFormNodePath(){
    return request('getCurrentFormNodePath', {});
  }
  reloadCurrentForm(){
    return request('reloadCurrentForm', {});
  }

  redirectTo(location, forceRefresh){
    return request('redirectTo', {location, forceRefresh}, {timeout: 10000});
  }
  parentMountWorkspace(siteKey: string, workspaceKey: string){
    return request('parentMountWorkspace', {siteKey, workspaceKey});
  }

  reloadThemeStyle(){
    return request('reloadThemeStyle', {});
  }

  createKeyPairGithub(){

    return request('createKeyPairGithub',{}, {timeout:90000});
  }

  derivePublicKey(privateKey: string){
    return request('derivePublicKey', { privateKey });
  }

  invalidateCache(){
    return request('invalidateCache', {});
  }

  updateCommunityTemplates() {
    return request('updateCommunityTemplates', {});
  }

  showOpenFolderDialog() {
    return request('showOpenFolderDialog', {});
  }

  /**
   * Get environment information (platform and packaging status)
   */
  getEnvironmentInfo() {
    return request('getEnvironmentInfo', {});
  }

  /**
   * Get current menu state (for web mode)
   */
  getMenuState() {
    return request('getMenuState', {});
  }

  /**
   * Execute a menu action (for web mode)
   */
  executeMenuAction(params: { action: string; data?: unknown }) {
    return request('executeMenuAction', params);
  }

}

export const instance = new API();
